// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: aggregator.sql

package gen

import (
	"context"
	"database/sql"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const createAggregatorWasteType = `-- name: CreateAggregatorWasteType :one
insert into aggregator_waste_types(aggregator_id,waste_id,alert_level) VALUES ($1,$2,$3) returning id, aggregator_id, waste_id, alert_level
`

type CreateAggregatorWasteTypeParams struct {
	AggregatorID int32           `json:"aggregator_id"`
	WasteID      int32           `json:"waste_id"`
	AlertLevel   sql.NullFloat64 `json:"alert_level"`
}

func (q *Queries) CreateAggregatorWasteType(ctx context.Context, arg CreateAggregatorWasteTypeParams) (AggregatorWasteType, error) {
	row := q.db.QueryRowContext(ctx, createAggregatorWasteType, arg.AggregatorID, arg.WasteID, arg.AlertLevel)
	var i AggregatorWasteType
	err := row.Scan(
		&i.ID,
		&i.AggregatorID,
		&i.WasteID,
		&i.AlertLevel,
	)
	return i, err
}

const createBuyer = `-- name: CreateBuyer :one
insert into
    buyers (
        company_id, company, first_name, last_name, calling_code, phone, administrative_level_1_location, location, is_active, lat, lng, created_at, updated_at,region,country_id
    )
values (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13,$14,$15
    ) returning id, company_id, company, country_id, first_name, last_name, is_active, region, calling_code, location, administrative_level_1_location, lat, lng, phone, created_at, updated_at
`

type CreateBuyerParams struct {
	CompanyID                    int32           `json:"company_id"`
	Company                      sql.NullString  `json:"company"`
	FirstName                    string          `json:"first_name"`
	LastName                     string          `json:"last_name"`
	CallingCode                  sql.NullString  `json:"calling_code"`
	Phone                        sql.NullString  `json:"phone"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Location                     sql.NullString  `json:"location"`
	IsActive                     bool            `json:"is_active"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	CreatedAt                    time.Time       `json:"created_at"`
	UpdatedAt                    time.Time       `json:"updated_at"`
	Region                       sql.NullString  `json:"region"`
	CountryID                    sql.NullInt32   `json:"country_id"`
}

func (q *Queries) CreateBuyer(ctx context.Context, arg CreateBuyerParams) (Buyer, error) {
	row := q.db.QueryRowContext(ctx, createBuyer,
		arg.CompanyID,
		arg.Company,
		arg.FirstName,
		arg.LastName,
		arg.CallingCode,
		arg.Phone,
		arg.AdministrativeLevel1Location,
		arg.Location,
		arg.IsActive,
		arg.Lat,
		arg.Lng,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Region,
		arg.CountryID,
	)
	var i Buyer
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Company,
		&i.CountryID,
		&i.FirstName,
		&i.LastName,
		&i.IsActive,
		&i.Region,
		&i.CallingCode,
		&i.Location,
		&i.AdministrativeLevel1Location,
		&i.Lat,
		&i.Lng,
		&i.Phone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPurchase = `-- name: CreatePurchase :one
insert into purchases(ref,company_id,supplier_id,total_weight,total_amount,dump) VALUES ($1,$2,$3,$4,$5,$6) returning id, ref, company_id, supplier_id, total_weight, total_amount, date, dump
`

type CreatePurchaseParams struct {
	Ref         string                `json:"ref"`
	CompanyID   int32                 `json:"company_id"`
	SupplierID  int32                 `json:"supplier_id"`
	TotalWeight sql.NullFloat64       `json:"total_weight"`
	TotalAmount sql.NullFloat64       `json:"total_amount"`
	Dump        pqtype.NullRawMessage `json:"dump"`
}

func (q *Queries) CreatePurchase(ctx context.Context, arg CreatePurchaseParams) (Purchase, error) {
	row := q.db.QueryRowContext(ctx, createPurchase,
		arg.Ref,
		arg.CompanyID,
		arg.SupplierID,
		arg.TotalWeight,
		arg.TotalAmount,
		arg.Dump,
	)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.Ref,
		&i.CompanyID,
		&i.SupplierID,
		&i.TotalWeight,
		&i.TotalAmount,
		&i.Date,
		&i.Dump,
	)
	return i, err
}

const createPurchaseItem = `-- name: CreatePurchaseItem :one
insert into purchase_items(company_id,purchase_id,waste_type_id,weight,cost_per_kg,total_amount) VALUES($1,$2,$3,$4,$5,$6) returning id, company_id, purchase_id, waste_type_id, weight, cost_per_kg, total_amount
`

type CreatePurchaseItemParams struct {
	CompanyID   int32           `json:"company_id"`
	PurchaseID  int32           `json:"purchase_id"`
	WasteTypeID int32           `json:"waste_type_id"`
	Weight      sql.NullFloat64 `json:"weight"`
	CostPerKg   sql.NullFloat64 `json:"cost_per_kg"`
	TotalAmount float64         `json:"total_amount"`
}

func (q *Queries) CreatePurchaseItem(ctx context.Context, arg CreatePurchaseItemParams) (PurchaseItem, error) {
	row := q.db.QueryRowContext(ctx, createPurchaseItem,
		arg.CompanyID,
		arg.PurchaseID,
		arg.WasteTypeID,
		arg.Weight,
		arg.CostPerKg,
		arg.TotalAmount,
	)
	var i PurchaseItem
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PurchaseID,
		&i.WasteTypeID,
		&i.Weight,
		&i.CostPerKg,
		&i.TotalAmount,
	)
	return i, err
}

const createSale = `-- name: CreateSale :one
insert into sales(ref,company_id,buyer_id,total_weight,total_amount,dump) VALUES ($1,$2,$3,$4,$5,$6) returning id, ref, company_id, buyer_id, total_weight, total_amount, date, dump
`

type CreateSaleParams struct {
	Ref         string                `json:"ref"`
	CompanyID   int32                 `json:"company_id"`
	BuyerID     int32                 `json:"buyer_id"`
	TotalWeight sql.NullFloat64       `json:"total_weight"`
	TotalAmount sql.NullFloat64       `json:"total_amount"`
	Dump        pqtype.NullRawMessage `json:"dump"`
}

func (q *Queries) CreateSale(ctx context.Context, arg CreateSaleParams) (Sale, error) {
	row := q.db.QueryRowContext(ctx, createSale,
		arg.Ref,
		arg.CompanyID,
		arg.BuyerID,
		arg.TotalWeight,
		arg.TotalAmount,
		arg.Dump,
	)
	var i Sale
	err := row.Scan(
		&i.ID,
		&i.Ref,
		&i.CompanyID,
		&i.BuyerID,
		&i.TotalWeight,
		&i.TotalAmount,
		&i.Date,
		&i.Dump,
	)
	return i, err
}

const createSaleItem = `-- name: CreateSaleItem :one
insert into sale_items(company_id,sale_id,waste_type_id,weight,cost_per_kg,total_amount) VALUES($1,$2,$3,$4,$5,$6) returning id, company_id, sale_id, waste_type_id, weight, cost_per_kg, total_amount
`

type CreateSaleItemParams struct {
	CompanyID   int32           `json:"company_id"`
	SaleID      int32           `json:"sale_id"`
	WasteTypeID int32           `json:"waste_type_id"`
	Weight      sql.NullFloat64 `json:"weight"`
	CostPerKg   sql.NullFloat64 `json:"cost_per_kg"`
	TotalAmount float64         `json:"total_amount"`
}

func (q *Queries) CreateSaleItem(ctx context.Context, arg CreateSaleItemParams) (SaleItem, error) {
	row := q.db.QueryRowContext(ctx, createSaleItem,
		arg.CompanyID,
		arg.SaleID,
		arg.WasteTypeID,
		arg.Weight,
		arg.CostPerKg,
		arg.TotalAmount,
	)
	var i SaleItem
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.SaleID,
		&i.WasteTypeID,
		&i.Weight,
		&i.CostPerKg,
		&i.TotalAmount,
	)
	return i, err
}

const createSupplier = `-- name: CreateSupplier :one
insert into
    suppliers (
        company_id, company, first_name, last_name, calling_code, phone, administrative_level_1_location, location, is_active, lat, lng, created_at, updated_at,region,country_id
    )
values (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13,$14,$15
    ) returning id, company_id, company, first_name, country_id, last_name, is_active, region, calling_code, location, administrative_level_1_location, lat, lng, phone, created_at, updated_at
`

type CreateSupplierParams struct {
	CompanyID                    int32           `json:"company_id"`
	Company                      sql.NullString  `json:"company"`
	FirstName                    string          `json:"first_name"`
	LastName                     string          `json:"last_name"`
	CallingCode                  sql.NullString  `json:"calling_code"`
	Phone                        sql.NullString  `json:"phone"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Location                     sql.NullString  `json:"location"`
	IsActive                     bool            `json:"is_active"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	CreatedAt                    time.Time       `json:"created_at"`
	UpdatedAt                    time.Time       `json:"updated_at"`
	Region                       sql.NullString  `json:"region"`
	CountryID                    sql.NullInt32   `json:"country_id"`
}

func (q *Queries) CreateSupplier(ctx context.Context, arg CreateSupplierParams) (Supplier, error) {
	row := q.db.QueryRowContext(ctx, createSupplier,
		arg.CompanyID,
		arg.Company,
		arg.FirstName,
		arg.LastName,
		arg.CallingCode,
		arg.Phone,
		arg.AdministrativeLevel1Location,
		arg.Location,
		arg.IsActive,
		arg.Lat,
		arg.Lng,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Region,
		arg.CountryID,
	)
	var i Supplier
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Company,
		&i.FirstName,
		&i.CountryID,
		&i.LastName,
		&i.IsActive,
		&i.Region,
		&i.CallingCode,
		&i.Location,
		&i.AdministrativeLevel1Location,
		&i.Lat,
		&i.Lng,
		&i.Phone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAggregatorWasteTypes = `-- name: DeleteAggregatorWasteTypes :exec
delete from aggregator_waste_types where aggregator_id =$1
`

func (q *Queries) DeleteAggregatorWasteTypes(ctx context.Context, aggregatorID int32) error {
	_, err := q.db.ExecContext(ctx, deleteAggregatorWasteTypes, aggregatorID)
	return err
}

const deleteBuyer = `-- name: DeleteBuyer :exec
delete from buyers where id = $1
`

func (q *Queries) DeleteBuyer(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteBuyer, id)
	return err
}

const deletePurchase = `-- name: DeletePurchase :exec
delete from purchases where id=$1
`

func (q *Queries) DeletePurchase(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deletePurchase, id)
	return err
}

const deleteSale = `-- name: DeleteSale :exec
delete from sales where id=$1
`

func (q *Queries) DeleteSale(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteSale, id)
	return err
}

const deleteSupplier = `-- name: DeleteSupplier :exec
delete from suppliers where id = $1
`

func (q *Queries) DeleteSupplier(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteSupplier, id)
	return err
}

const getAggregatorWasteTypes = `-- name: GetAggregatorWasteTypes :many
select id, aggregator_id, waste_id, alert_level from aggregator_waste_types where aggregator_id = $1
`

func (q *Queries) GetAggregatorWasteTypes(ctx context.Context, aggregatorID int32) ([]AggregatorWasteType, error) {
	rows, err := q.db.QueryContext(ctx, getAggregatorWasteTypes, aggregatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregatorWasteType{}
	for rows.Next() {
		var i AggregatorWasteType
		if err := rows.Scan(
			&i.ID,
			&i.AggregatorID,
			&i.WasteID,
			&i.AlertLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryItem = `-- name: GetInventoryItem :one
select id, company_id, waste_type_id, total_weight from inventory where  waste_type_id=$1 and company_id = $2
`

type GetInventoryItemParams struct {
	WasteTypeID sql.NullInt32 `json:"waste_type_id"`
	CompanyID   int32         `json:"company_id"`
}

func (q *Queries) GetInventoryItem(ctx context.Context, arg GetInventoryItemParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, getInventoryItem, arg.WasteTypeID, arg.CompanyID)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.WasteTypeID,
		&i.TotalWeight,
	)
	return i, err
}

const insertToInventory = `-- name: InsertToInventory :exec
insert into inventory(waste_type_id,company_id,total_weight) VALUES($1,$2,$3)
`

type InsertToInventoryParams struct {
	WasteTypeID sql.NullInt32 `json:"waste_type_id"`
	CompanyID   int32         `json:"company_id"`
	TotalWeight float64       `json:"total_weight"`
}

func (q *Queries) InsertToInventory(ctx context.Context, arg InsertToInventoryParams) error {
	_, err := q.db.ExecContext(ctx, insertToInventory, arg.WasteTypeID, arg.CompanyID, arg.TotalWeight)
	return err
}

const inventoryItemCount = `-- name: InventoryItemCount :one
select count(*) from inventory where waste_type_id=$1 and company_id = $2
`

type InventoryItemCountParams struct {
	WasteTypeID sql.NullInt32 `json:"waste_type_id"`
	CompanyID   int32         `json:"company_id"`
}

func (q *Queries) InventoryItemCount(ctx context.Context, arg InventoryItemCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, inventoryItemCount, arg.WasteTypeID, arg.CompanyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const makeCashPayment = `-- name: MakeCashPayment :one
insert into sale_transactions(ref,sale_id,company_id,payment_method,amount,transaction_date) VALUES($1,$2,$3,$4,$5,$6) returning ref, id, sale_id, company_id, payment_method, checkout_request_id, merchant_request_id, card_mask, msisdn_idnum, transaction_date, receipt_no, amount, mpesa_result_code, mpesa_result_desc, ipay_status, created_at, updated_at
`

type MakeCashPaymentParams struct {
	Ref             string       `json:"ref"`
	SaleID          int32        `json:"sale_id"`
	CompanyID       int32        `json:"company_id"`
	PaymentMethod   string       `json:"payment_method"`
	Amount          string       `json:"amount"`
	TransactionDate sql.NullTime `json:"transaction_date"`
}

func (q *Queries) MakeCashPayment(ctx context.Context, arg MakeCashPaymentParams) (SaleTransaction, error) {
	row := q.db.QueryRowContext(ctx, makeCashPayment,
		arg.Ref,
		arg.SaleID,
		arg.CompanyID,
		arg.PaymentMethod,
		arg.Amount,
		arg.TransactionDate,
	)
	var i SaleTransaction
	err := row.Scan(
		&i.Ref,
		&i.ID,
		&i.SaleID,
		&i.CompanyID,
		&i.PaymentMethod,
		&i.CheckoutRequestID,
		&i.MerchantRequestID,
		&i.CardMask,
		&i.MsisdnIdnum,
		&i.TransactionDate,
		&i.ReceiptNo,
		&i.Amount,
		&i.MpesaResultCode,
		&i.MpesaResultDesc,
		&i.IpayStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const makePurchaseCashPayment = `-- name: MakePurchaseCashPayment :one
insert into purchase_transactions(ref,purchase_id,company_id,payment_method,amount,transaction_date) VALUES($1,$2,$3,$4,$5,$6) returning ref, id, purchase_id, company_id, payment_method, checkout_request_id, merchant_request_id, card_mask, msisdn_idnum, transaction_date, receipt_no, amount, mpesa_result_code, mpesa_result_desc, ipay_status, created_at, updated_at
`

type MakePurchaseCashPaymentParams struct {
	Ref             string       `json:"ref"`
	PurchaseID      int32        `json:"purchase_id"`
	CompanyID       int32        `json:"company_id"`
	PaymentMethod   string       `json:"payment_method"`
	Amount          string       `json:"amount"`
	TransactionDate sql.NullTime `json:"transaction_date"`
}

func (q *Queries) MakePurchaseCashPayment(ctx context.Context, arg MakePurchaseCashPaymentParams) (PurchaseTransaction, error) {
	row := q.db.QueryRowContext(ctx, makePurchaseCashPayment,
		arg.Ref,
		arg.PurchaseID,
		arg.CompanyID,
		arg.PaymentMethod,
		arg.Amount,
		arg.TransactionDate,
	)
	var i PurchaseTransaction
	err := row.Scan(
		&i.Ref,
		&i.ID,
		&i.PurchaseID,
		&i.CompanyID,
		&i.PaymentMethod,
		&i.CheckoutRequestID,
		&i.MerchantRequestID,
		&i.CardMask,
		&i.MsisdnIdnum,
		&i.TransactionDate,
		&i.ReceiptNo,
		&i.Amount,
		&i.MpesaResultCode,
		&i.MpesaResultDesc,
		&i.IpayStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setBuyerActiveInactiveStatus = `-- name: SetBuyerActiveInactiveStatus :exec
update buyers set is_active=$1 where id=$2
`

type SetBuyerActiveInactiveStatusParams struct {
	IsActive bool  `json:"is_active"`
	ID       int32 `json:"id"`
}

func (q *Queries) SetBuyerActiveInactiveStatus(ctx context.Context, arg SetBuyerActiveInactiveStatusParams) error {
	_, err := q.db.ExecContext(ctx, setBuyerActiveInactiveStatus, arg.IsActive, arg.ID)
	return err
}

const setSupplierActiveInactiveStatus = `-- name: SetSupplierActiveInactiveStatus :exec
update suppliers set is_active=$1 where id=$2
`

type SetSupplierActiveInactiveStatusParams struct {
	IsActive bool  `json:"is_active"`
	ID       int32 `json:"id"`
}

func (q *Queries) SetSupplierActiveInactiveStatus(ctx context.Context, arg SetSupplierActiveInactiveStatusParams) error {
	_, err := q.db.ExecContext(ctx, setSupplierActiveInactiveStatus, arg.IsActive, arg.ID)
	return err
}

const updateBuyer = `-- name: UpdateBuyer :exec
update buyers set company_id=$1,company=$2,first_name=$3,last_name=$4,calling_code=$5,phone=$6,administrative_level_1_location=$7,location=$8,is_active=$9,lat=$10,lng=$11 ,region=$12 ,country_id=$13 where id=$14
`

type UpdateBuyerParams struct {
	CompanyID                    int32           `json:"company_id"`
	Company                      sql.NullString  `json:"company"`
	FirstName                    string          `json:"first_name"`
	LastName                     string          `json:"last_name"`
	CallingCode                  sql.NullString  `json:"calling_code"`
	Phone                        sql.NullString  `json:"phone"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Location                     sql.NullString  `json:"location"`
	IsActive                     bool            `json:"is_active"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	Region                       sql.NullString  `json:"region"`
	CountryID                    sql.NullInt32   `json:"country_id"`
	ID                           int32           `json:"id"`
}

func (q *Queries) UpdateBuyer(ctx context.Context, arg UpdateBuyerParams) error {
	_, err := q.db.ExecContext(ctx, updateBuyer,
		arg.CompanyID,
		arg.Company,
		arg.FirstName,
		arg.LastName,
		arg.CallingCode,
		arg.Phone,
		arg.AdministrativeLevel1Location,
		arg.Location,
		arg.IsActive,
		arg.Lat,
		arg.Lng,
		arg.Region,
		arg.CountryID,
		arg.ID,
	)
	return err
}

const updateInventoryItem = `-- name: UpdateInventoryItem :exec
update inventory set total_weight=$1 where id =$2
`

type UpdateInventoryItemParams struct {
	TotalWeight float64 `json:"total_weight"`
	ID          int32   `json:"id"`
}

func (q *Queries) UpdateInventoryItem(ctx context.Context, arg UpdateInventoryItemParams) error {
	_, err := q.db.ExecContext(ctx, updateInventoryItem, arg.TotalWeight, arg.ID)
	return err
}

const updateSupplier = `-- name: UpdateSupplier :exec
update suppliers set company_id=$1,company=$2,first_name=$3,last_name=$4,calling_code=$5,phone=$6,administrative_level_1_location=$7,location=$8,is_active=$9,lat=$10,lng=$11 ,region=$12,country_id=$13 where id=$14
`

type UpdateSupplierParams struct {
	CompanyID                    int32           `json:"company_id"`
	Company                      sql.NullString  `json:"company"`
	FirstName                    string          `json:"first_name"`
	LastName                     string          `json:"last_name"`
	CallingCode                  sql.NullString  `json:"calling_code"`
	Phone                        sql.NullString  `json:"phone"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Location                     sql.NullString  `json:"location"`
	IsActive                     bool            `json:"is_active"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	Region                       sql.NullString  `json:"region"`
	CountryID                    sql.NullInt32   `json:"country_id"`
	ID                           int32           `json:"id"`
}

func (q *Queries) UpdateSupplier(ctx context.Context, arg UpdateSupplierParams) error {
	_, err := q.db.ExecContext(ctx, updateSupplier,
		arg.CompanyID,
		arg.Company,
		arg.FirstName,
		arg.LastName,
		arg.CallingCode,
		arg.Phone,
		arg.AdministrativeLevel1Location,
		arg.Location,
		arg.IsActive,
		arg.Lat,
		arg.Lng,
		arg.Region,
		arg.CountryID,
		arg.ID,
	)
	return err
}
