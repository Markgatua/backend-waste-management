// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: collection_requests.sql

package gen

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const cancelCollectionRequest = `-- name: CancelCollectionRequest :exec
update collection_requests set status = 4 where id = $1
`

func (q *Queries) CancelCollectionRequest(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, cancelCollectionRequest, id)
	return err
}

const changeCollectionRequestStatus = `-- name: ChangeCollectionRequestStatus :exec
update collection_requests set status = $1 where id=$2
`

type ChangeCollectionRequestStatusParams struct {
	Status int32 `json:"status"`
	ID     int32 `json:"id"`
}

func (q *Queries) ChangeCollectionRequestStatus(ctx context.Context, arg ChangeCollectionRequestStatusParams) error {
	_, err := q.db.ExecContext(ctx, changeCollectionRequestStatus, arg.Status, arg.ID)
	return err
}

const collectionWeightTotals = `-- name: CollectionWeightTotals :one
select sum(collection_request_waste_items.weight) as total_weight,waste_types.name from collection_request_waste_items 
inner join waste_types on waste_types.id=collection_request_waste_items.waste_type_id 
inner join collection_requests on collection_requests.id=collection_request_waste_items.collection_request_id
where collection_requests.producer_id=$1 GROUP BY waste_types.name
`

type CollectionWeightTotalsRow struct {
	TotalWeight int64  `json:"total_weight"`
	Name        string `json:"name"`
}

func (q *Queries) CollectionWeightTotals(ctx context.Context, producerID int32) (CollectionWeightTotalsRow, error) {
	row := q.db.QueryRowContext(ctx, collectionWeightTotals, producerID)
	var i CollectionWeightTotalsRow
	err := row.Scan(&i.TotalWeight, &i.Name)
	return i, err
}

const completeCollectionRequest = `-- name: CompleteCollectionRequest :exec
update collection_requests set status = 5 where id = $1
`

func (q *Queries) CompleteCollectionRequest(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, completeCollectionRequest, id)
	return err
}

const confirmCollectionRequest = `-- name: ConfirmCollectionRequest :exec
update collection_requests set status = 2 where id = $1
`

func (q *Queries) ConfirmCollectionRequest(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, confirmCollectionRequest, id)
	return err
}

const getAggregatorNewRequests = `-- name: GetAggregatorNewRequests :many
SELECT
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_time_stamp_id, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    producer.name AS producer_name,
    producer.location AS producer_location
FROM
    collection_requests
LEFT JOIN
    companies AS producer ON producer.id = collection_requests.producer_id
WHERE
    collection_requests.collector_id = $1 AND collection_requests.status = false
GROUP BY
    collection_requests.id, producer.name, producer.location
`

type GetAggregatorNewRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	PickupTimeStampID            int32           `json:"pickup_time_stamp_id"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	ProducerName                 sql.NullString  `json:"producer_name"`
	ProducerLocation             sql.NullString  `json:"producer_location"`
}

func (q *Queries) GetAggregatorNewRequests(ctx context.Context, collectorID int32) ([]GetAggregatorNewRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAggregatorNewRequests, collectorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAggregatorNewRequestsRow{}
	for rows.Next() {
		var i GetAggregatorNewRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupTimeStampID,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.ProducerName,
			&i.ProducerLocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCancelledCollectionRequests = `-- name: GetAllCancelledCollectionRequests :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_time_stamp_id, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
WHERE collection_requests.cancelled=4
`

type GetAllCancelledCollectionRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	PickupTimeStampID            int32           `json:"pickup_time_stamp_id"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	AggregatorName               sql.NullString  `json:"aggregator_name"`
	ChampionName                 sql.NullString  `json:"champion_name"`
	SecondCollectorName          sql.NullString  `json:"second_collector_name"`
}

func (q *Queries) GetAllCancelledCollectionRequests(ctx context.Context) ([]GetAllCancelledCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCancelledCollectionRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCancelledCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllCancelledCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupTimeStampID,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCollectionRequests = `-- name: GetAllCollectionRequests :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_time_stamp_id, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
`

type GetAllCollectionRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	PickupTimeStampID            int32           `json:"pickup_time_stamp_id"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	AggregatorName               sql.NullString  `json:"aggregator_name"`
	ChampionName                 sql.NullString  `json:"champion_name"`
	SecondCollectorName          sql.NullString  `json:"second_collector_name"`
}

func (q *Queries) GetAllCollectionRequests(ctx context.Context) ([]GetAllCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCollectionRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupTimeStampID,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCollectionRequestsForACollector = `-- name: GetAllCollectionRequestsForACollector :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_time_stamp_id, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
WHERE collection_requests.collector_id=$1
`

type GetAllCollectionRequestsForACollectorRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	PickupTimeStampID            int32           `json:"pickup_time_stamp_id"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	AggregatorName               sql.NullString  `json:"aggregator_name"`
	ChampionName                 sql.NullString  `json:"champion_name"`
	SecondCollectorName          sql.NullString  `json:"second_collector_name"`
}

func (q *Queries) GetAllCollectionRequestsForACollector(ctx context.Context, collectorID int32) ([]GetAllCollectionRequestsForACollectorRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCollectionRequestsForACollector, collectorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCollectionRequestsForACollectorRow{}
	for rows.Next() {
		var i GetAllCollectionRequestsForACollectorRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupTimeStampID,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompletedCollectionRequests = `-- name: GetAllCompletedCollectionRequests :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_time_stamp_id, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
WHERE collection_requests.status=5
`

type GetAllCompletedCollectionRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	PickupTimeStampID            int32           `json:"pickup_time_stamp_id"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	AggregatorName               sql.NullString  `json:"aggregator_name"`
	ChampionName                 sql.NullString  `json:"champion_name"`
	SecondCollectorName          sql.NullString  `json:"second_collector_name"`
}

func (q *Queries) GetAllCompletedCollectionRequests(ctx context.Context) ([]GetAllCompletedCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCompletedCollectionRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCompletedCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllCompletedCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupTimeStampID,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPendingCollectionRequests = `-- name: GetAllPendingCollectionRequests :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_time_stamp_id, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
WHERE collection_requests.confirmed=2
`

type GetAllPendingCollectionRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	PickupTimeStampID            int32           `json:"pickup_time_stamp_id"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	AggregatorName               sql.NullString  `json:"aggregator_name"`
	ChampionName                 sql.NullString  `json:"champion_name"`
	SecondCollectorName          sql.NullString  `json:"second_collector_name"`
}

func (q *Queries) GetAllPendingCollectionRequests(ctx context.Context) ([]GetAllPendingCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPendingCollectionRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllPendingCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllPendingCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupTimeStampID,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPendingConfirmationCollectionRequests = `-- name: GetAllPendingConfirmationCollectionRequests :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_time_stamp_id, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
WHERE collection_requests.status=2
`

type GetAllPendingConfirmationCollectionRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	PickupTimeStampID            int32           `json:"pickup_time_stamp_id"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	AggregatorName               sql.NullString  `json:"aggregator_name"`
	ChampionName                 sql.NullString  `json:"champion_name"`
	SecondCollectorName          sql.NullString  `json:"second_collector_name"`
}

func (q *Queries) GetAllPendingConfirmationCollectionRequests(ctx context.Context) ([]GetAllPendingConfirmationCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPendingConfirmationCollectionRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllPendingConfirmationCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllPendingConfirmationCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupTimeStampID,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProducerCompletedCollectionRequests = `-- name: GetAllProducerCompletedCollectionRequests :many
SELECT
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_time_stamp_id, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    collector.name AS collector_name,
    CAST(SUM(totals.weight) AS DECIMAL(10,2)) AS total_weight
FROM
    collection_requests
LEFT JOIN
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN
    collection_request_waste_items AS totals ON totals.collection_request_id = collection_requests.id
WHERE
    collection_requests.producer_id = $1 AND collection_requests.status = true
GROUP BY
    collection_requests.id, collector.name
`

type GetAllProducerCompletedCollectionRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	PickupTimeStampID            int32           `json:"pickup_time_stamp_id"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	CollectorName                sql.NullString  `json:"collector_name"`
	TotalWeight                  string          `json:"total_weight"`
}

func (q *Queries) GetAllProducerCompletedCollectionRequests(ctx context.Context, producerID int32) ([]GetAllProducerCompletedCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllProducerCompletedCollectionRequests, producerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProducerCompletedCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllProducerCompletedCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupTimeStampID,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.CollectorName,
			&i.TotalWeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProducerPendingCollectionRequests = `-- name: GetAllProducerPendingCollectionRequests :many
SELECT
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_time_stamp_id, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    collector.name AS collector_name,
    CAST(SUM(totals.weight) AS DECIMAL(10,2)) AS total_weight
FROM
    collection_requests
LEFT JOIN
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN
    collection_request_waste_items AS totals ON totals.collection_request_id = collection_requests.id
WHERE
    collection_requests.producer_id = $1 AND collection_requests.status = false
GROUP BY
    collection_requests.id, collector.name
`

type GetAllProducerPendingCollectionRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	PickupTimeStampID            int32           `json:"pickup_time_stamp_id"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	CollectorName                sql.NullString  `json:"collector_name"`
	TotalWeight                  string          `json:"total_weight"`
}

func (q *Queries) GetAllProducerPendingCollectionRequests(ctx context.Context, producerID int32) ([]GetAllProducerPendingCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllProducerPendingCollectionRequests, producerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProducerPendingCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllProducerPendingCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupTimeStampID,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.CollectorName,
			&i.TotalWeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionRequest = `-- name: GetCollectionRequest :one
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_time_stamp_id, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at  
FROM 
    collection_requests
WHERE collection_requests.id=$1
`

func (q *Queries) GetCollectionRequest(ctx context.Context, id int32) (CollectionRequest, error) {
	row := q.db.QueryRowContext(ctx, getCollectionRequest, id)
	var i CollectionRequest
	err := row.Scan(
		&i.ID,
		&i.ProducerID,
		&i.CollectorID,
		&i.RequestDate,
		&i.PickupTimeStampID,
		&i.Location,
		&i.AdministrativeLevel1Location,
		&i.Lat,
		&i.Lng,
		&i.PickupDate,
		&i.Status,
		&i.FirstContactPerson,
		&i.SecondContactPerson,
		&i.CreatedAt,
	)
	return i, err
}

const getCollectionRequestsInArray = `-- name: GetCollectionRequestsInArray :many
select collection_requests.id,collection_requests.producer_id, companies.name as champion_name,collection_requests.collector_id,
collection_requests.request_date,collection_requests.pickup_date,collection_requests.status,collection_requests.lat,
collection_requests.lng,collection_requests.created_at,collection_requests.pickup_time_stamp_id,collection_requests.id,
collection_requests.first_contact_person,collection_requests.second_contact_person,pickup_time_stamps.stamp,
pickup_time_stamps.time_range from collection_requests 
inner join pickup_time_stamps on pickup_time_stamps.id=collection_requests.pickup_time_stamp_id
inner join companies on companies.id=collection_requests.producer_id
where collection_requests.id=ANY($1::int[])
`

type GetCollectionRequestsInArrayRow struct {
	ID                  int32           `json:"id"`
	ProducerID          int32           `json:"producer_id"`
	ChampionName        string          `json:"champion_name"`
	CollectorID         int32           `json:"collector_id"`
	RequestDate         time.Time       `json:"request_date"`
	PickupDate          sql.NullTime    `json:"pickup_date"`
	Status              int32           `json:"status"`
	Lat                 sql.NullFloat64 `json:"lat"`
	Lng                 sql.NullFloat64 `json:"lng"`
	CreatedAt           time.Time       `json:"created_at"`
	PickupTimeStampID   int32           `json:"pickup_time_stamp_id"`
	ID_2                int32           `json:"id_2"`
	FirstContactPerson  string          `json:"first_contact_person"`
	SecondContactPerson sql.NullString  `json:"second_contact_person"`
	Stamp               string          `json:"stamp"`
	TimeRange           string          `json:"time_range"`
}

func (q *Queries) GetCollectionRequestsInArray(ctx context.Context, collectionids []int32) ([]GetCollectionRequestsInArrayRow, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionRequestsInArray, pq.Array(collectionids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCollectionRequestsInArrayRow{}
	for rows.Next() {
		var i GetCollectionRequestsInArrayRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.ChampionName,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupDate,
			&i.Status,
			&i.Lat,
			&i.Lng,
			&i.CreatedAt,
			&i.PickupTimeStampID,
			&i.ID_2,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.Stamp,
			&i.TimeRange,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionScheduleInArray = `-- name: GetCollectionScheduleInArray :many
select champion_pickup_times.id as pickup_time_id,champion_pickup_times.champion_aggregator_assignment_id,champion_pickup_times.pickup_time_stamp_id,
champion_pickup_times.pickup_day,champion_aggregator_assignments.champion_id,champion_aggregator_assignments.collector_id,companies.lat,
companies.lng,companies.name as champion_name,companies.location,companies.contact_person1_first_name,companies.contact_person1_last_name,
companies.contact_person1_phone,companies.contact_person1_email,companies.contact_person2_email,companies.administrative_level_1_location,
companies.contact_person2_first_name,companies.contact_person2_last_name,companies.contact_person2_phone,pickup_time_stamps.stamp,
pickup_time_stamps.time_range from champion_pickup_times 
left join pickup_time_stamps on pickup_time_stamps.id=champion_pickup_times.pickup_time_stamp_id
left join champion_aggregator_assignments on champion_pickup_times.champion_aggregator_assignment_id=champion_aggregator_assignments.id
left join companies on companies.id = champion_aggregator_assignments.champion_id
where champion_pickup_times.id=ANY($1::int[])
`

type GetCollectionScheduleInArrayRow struct {
	PickupTimeID                   int32           `json:"pickup_time_id"`
	ChampionAggregatorAssignmentID int32           `json:"champion_aggregator_assignment_id"`
	PickupTimeStampID              int32           `json:"pickup_time_stamp_id"`
	PickupDay                      string          `json:"pickup_day"`
	ChampionID                     sql.NullInt32   `json:"champion_id"`
	CollectorID                    sql.NullInt32   `json:"collector_id"`
	Lat                            sql.NullFloat64 `json:"lat"`
	Lng                            sql.NullFloat64 `json:"lng"`
	ChampionName                   sql.NullString  `json:"champion_name"`
	Location                       sql.NullString  `json:"location"`
	ContactPerson1FirstName        sql.NullString  `json:"contact_person1_first_name"`
	ContactPerson1LastName         sql.NullString  `json:"contact_person1_last_name"`
	ContactPerson1Phone            sql.NullString  `json:"contact_person1_phone"`
	ContactPerson1Email            sql.NullString  `json:"contact_person1_email"`
	ContactPerson2Email            sql.NullString  `json:"contact_person2_email"`
	AdministrativeLevel1Location   sql.NullString  `json:"administrative_level_1_location"`
	ContactPerson2FirstName        sql.NullString  `json:"contact_person2_first_name"`
	ContactPerson2LastName         sql.NullString  `json:"contact_person2_last_name"`
	ContactPerson2Phone            sql.NullString  `json:"contact_person2_phone"`
	Stamp                          sql.NullString  `json:"stamp"`
	TimeRange                      sql.NullString  `json:"time_range"`
}

func (q *Queries) GetCollectionScheduleInArray(ctx context.Context, pickuptimeids []int32) ([]GetCollectionScheduleInArrayRow, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionScheduleInArray, pq.Array(pickuptimeids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCollectionScheduleInArrayRow{}
	for rows.Next() {
		var i GetCollectionScheduleInArrayRow
		if err := rows.Scan(
			&i.PickupTimeID,
			&i.ChampionAggregatorAssignmentID,
			&i.PickupTimeStampID,
			&i.PickupDay,
			&i.ChampionID,
			&i.CollectorID,
			&i.Lat,
			&i.Lng,
			&i.ChampionName,
			&i.Location,
			&i.ContactPerson1FirstName,
			&i.ContactPerson1LastName,
			&i.ContactPerson1Phone,
			&i.ContactPerson1Email,
			&i.ContactPerson2Email,
			&i.AdministrativeLevel1Location,
			&i.ContactPerson2FirstName,
			&i.ContactPerson2LastName,
			&i.ContactPerson2Phone,
			&i.Stamp,
			&i.TimeRange,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionStats = `-- name: GetCollectionStats :many
SELECT
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_time_stamp_id, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    CAST(SUM(totals.weight) AS DECIMAL(10,2)) AS total_weight
FROM
    collection_requests
LEFT JOIN
    collection_request_waste_items AS totals ON totals.collection_request_id = collection_requests.id
WHERE
    collection_requests.producer_id = $1
GROUP BY
    collection_requests.id
`

type GetCollectionStatsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	PickupTimeStampID            int32           `json:"pickup_time_stamp_id"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	TotalWeight                  string          `json:"total_weight"`
}

func (q *Queries) GetCollectionStats(ctx context.Context, producerID int32) ([]GetCollectionStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionStats, producerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCollectionStatsRow{}
	for rows.Next() {
		var i GetCollectionStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupTimeStampID,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.TotalWeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestCollection = `-- name: GetLatestCollection :one
SELECT
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_time_stamp_id, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    collector.name AS collector_name,
    CAST(SUM(totals.weight) AS DECIMAL(10,2)) AS total_weight
FROM
    collection_requests
LEFT JOIN
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN
    collection_request_waste_items AS totals ON totals.collection_request_id = collection_requests.id
WHERE
    collection_requests.id = $1
GROUP BY
    collection_requests.id, collector.name
`

type GetLatestCollectionRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	PickupTimeStampID            int32           `json:"pickup_time_stamp_id"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	CollectorName                sql.NullString  `json:"collector_name"`
	TotalWeight                  string          `json:"total_weight"`
}

func (q *Queries) GetLatestCollection(ctx context.Context, id int32) (GetLatestCollectionRow, error) {
	row := q.db.QueryRowContext(ctx, getLatestCollection, id)
	var i GetLatestCollectionRow
	err := row.Scan(
		&i.ID,
		&i.ProducerID,
		&i.CollectorID,
		&i.RequestDate,
		&i.PickupTimeStampID,
		&i.Location,
		&i.AdministrativeLevel1Location,
		&i.Lat,
		&i.Lng,
		&i.PickupDate,
		&i.Status,
		&i.FirstContactPerson,
		&i.SecondContactPerson,
		&i.CreatedAt,
		&i.CollectorName,
		&i.TotalWeight,
	)
	return i, err
}

const getProducerLatestCollectionId = `-- name: GetProducerLatestCollectionId :one
SELECT id, producer_id, collector_id, request_date, pickup_time_stamp_id, location, administrative_level_1_location, lat, lng, pickup_date, status, first_contact_person, second_contact_person, created_at
FROM collection_requests
WHERE producer_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetProducerLatestCollectionId(ctx context.Context, producerID int32) (CollectionRequest, error) {
	row := q.db.QueryRowContext(ctx, getProducerLatestCollectionId, producerID)
	var i CollectionRequest
	err := row.Scan(
		&i.ID,
		&i.ProducerID,
		&i.CollectorID,
		&i.RequestDate,
		&i.PickupTimeStampID,
		&i.Location,
		&i.AdministrativeLevel1Location,
		&i.Lat,
		&i.Lng,
		&i.PickupDate,
		&i.Status,
		&i.FirstContactPerson,
		&i.SecondContactPerson,
		&i.CreatedAt,
	)
	return i, err
}

const getWasteItemsProducerData = `-- name: GetWasteItemsProducerData :many
SELECT
    CAST(SUM(collection_request_waste_items.weight) AS DECIMAL(10,2)) AS total_weight,
    waste.name AS waste_name,
    collections.status AS collection_status
FROM
    collection_request_waste_items
JOIN
    waste_types AS waste ON collection_request_waste_items.waste_type_id = waste.id
LEFT JOIN
    collection_requests AS collections ON collections.id = collection_request_waste_items.collection_request_id
WHERE
    collections.producer_id = $1
GROUP BY
    collections.status, waste.name
`

type GetWasteItemsProducerDataRow struct {
	TotalWeight      string        `json:"total_weight"`
	WasteName        string        `json:"waste_name"`
	CollectionStatus sql.NullInt32 `json:"collection_status"`
}

func (q *Queries) GetWasteItemsProducerData(ctx context.Context, producerID int32) ([]GetWasteItemsProducerDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getWasteItemsProducerData, producerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWasteItemsProducerDataRow{}
	for rows.Next() {
		var i GetWasteItemsProducerDataRow
		if err := rows.Scan(&i.TotalWeight, &i.WasteName, &i.CollectionStatus); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertNewCollectionRequest = `-- name: InsertNewCollectionRequest :exec

insert into collection_requests( producer_id,collector_id,request_date,pickup_time_stamp_id,location,lat,lng,administrative_level_1_location,first_contact_person,status ) values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) returning id, producer_id, collector_id, request_date, pickup_time_stamp_id, location, administrative_level_1_location, lat, lng, pickup_date, status, first_contact_person, second_contact_person, created_at
`

type InsertNewCollectionRequestParams struct {
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	PickupTimeStampID            int32           `json:"pickup_time_stamp_id"`
	Location                     sql.NullString  `json:"location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	FirstContactPerson           string          `json:"first_contact_person"`
	Status                       int32           `json:"status"`
}

// collection_requests.sql
func (q *Queries) InsertNewCollectionRequest(ctx context.Context, arg InsertNewCollectionRequestParams) error {
	_, err := q.db.ExecContext(ctx, insertNewCollectionRequest,
		arg.ProducerID,
		arg.CollectorID,
		arg.RequestDate,
		arg.PickupTimeStampID,
		arg.Location,
		arg.Lat,
		arg.Lng,
		arg.AdministrativeLevel1Location,
		arg.FirstContactPerson,
		arg.Status,
	)
	return err
}

const updateCollectionRequest = `-- name: UpdateCollectionRequest :exec
update collection_requests
set
    pickup_date = $1,
    status = $2
where id = $3
`

type UpdateCollectionRequestParams struct {
	PickupDate sql.NullTime `json:"pickup_date"`
	Status     int32        `json:"status"`
	ID         int32        `json:"id"`
}

func (q *Queries) UpdateCollectionRequest(ctx context.Context, arg UpdateCollectionRequestParams) error {
	_, err := q.db.ExecContext(ctx, updateCollectionRequest, arg.PickupDate, arg.Status, arg.ID)
	return err
}
