// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: collection_requests.sql

package gen

import (
	"context"
	"database/sql"
	"time"
)

const cancelCollectionRequest = `-- name: CancelCollectionRequest :exec
update collection_requests set cancelled = $1 where id = $2
`

type CancelCollectionRequestParams struct {
	Cancelled sql.NullBool `json:"cancelled"`
	ID        int32        `json:"id"`
}

func (q *Queries) CancelCollectionRequest(ctx context.Context, arg CancelCollectionRequestParams) error {
	_, err := q.db.ExecContext(ctx, cancelCollectionRequest, arg.Cancelled, arg.ID)
	return err
}

const collectionWeightTotals = `-- name: CollectionWeightTotals :one
select sum(waste_items.weight) as total_weight,waste_types.name from waste_items 
inner join waste_types on waste_types.id=waste_items.waste_type_id 
inner join collection_requests on collection_requests.id=waste_items.collection_request_id
where collection_requests.producer_id=$1 GROUP BY waste_types.name
`

type CollectionWeightTotalsRow struct {
	TotalWeight int64  `json:"total_weight"`
	Name        string `json:"name"`
}

func (q *Queries) CollectionWeightTotals(ctx context.Context, producerID int32) (CollectionWeightTotalsRow, error) {
	row := q.db.QueryRowContext(ctx, collectionWeightTotals, producerID)
	var i CollectionWeightTotalsRow
	err := row.Scan(&i.TotalWeight, &i.Name)
	return i, err
}

const confirmCollectionRequest = `-- name: ConfirmCollectionRequest :exec
update collection_requests set confirmed = $1 where id = $2
`

type ConfirmCollectionRequestParams struct {
	Confirmed sql.NullBool `json:"confirmed"`
	ID        int32        `json:"id"`
}

func (q *Queries) ConfirmCollectionRequest(ctx context.Context, arg ConfirmCollectionRequestParams) error {
	_, err := q.db.ExecContext(ctx, confirmCollectionRequest, arg.Confirmed, arg.ID)
	return err
}

const getAllCancelledCollectionRequests = `-- name: GetAllCancelledCollectionRequests :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_date, collection_requests.confirmed, collection_requests.cancelled, collection_requests.status, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
WHERE collection_requests.cancelled=$1
`

type GetAllCancelledCollectionRequestsRow struct {
	ID                  int32          `json:"id"`
	ProducerID          int32          `json:"producer_id"`
	CollectorID         int32          `json:"collector_id"`
	RequestDate         time.Time      `json:"request_date"`
	PickupDate          sql.NullTime   `json:"pickup_date"`
	Confirmed           sql.NullBool   `json:"confirmed"`
	Cancelled           sql.NullBool   `json:"cancelled"`
	Status              sql.NullBool   `json:"status"`
	CreatedAt           time.Time      `json:"created_at"`
	AggregatorName      sql.NullString `json:"aggregator_name"`
	ChampionName        sql.NullString `json:"champion_name"`
	SecondCollectorName sql.NullString `json:"second_collector_name"`
}

func (q *Queries) GetAllCancelledCollectionRequests(ctx context.Context, cancelled sql.NullBool) ([]GetAllCancelledCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCancelledCollectionRequests, cancelled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCancelledCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllCancelledCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupDate,
			&i.Confirmed,
			&i.Cancelled,
			&i.Status,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCollectionRequests = `-- name: GetAllCollectionRequests :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_date, collection_requests.confirmed, collection_requests.cancelled, collection_requests.status, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
`

type GetAllCollectionRequestsRow struct {
	ID                  int32          `json:"id"`
	ProducerID          int32          `json:"producer_id"`
	CollectorID         int32          `json:"collector_id"`
	RequestDate         time.Time      `json:"request_date"`
	PickupDate          sql.NullTime   `json:"pickup_date"`
	Confirmed           sql.NullBool   `json:"confirmed"`
	Cancelled           sql.NullBool   `json:"cancelled"`
	Status              sql.NullBool   `json:"status"`
	CreatedAt           time.Time      `json:"created_at"`
	AggregatorName      sql.NullString `json:"aggregator_name"`
	ChampionName        sql.NullString `json:"champion_name"`
	SecondCollectorName sql.NullString `json:"second_collector_name"`
}

func (q *Queries) GetAllCollectionRequests(ctx context.Context) ([]GetAllCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCollectionRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupDate,
			&i.Confirmed,
			&i.Cancelled,
			&i.Status,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCollectionRequestsForACollector = `-- name: GetAllCollectionRequestsForACollector :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_date, collection_requests.confirmed, collection_requests.cancelled, collection_requests.status, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
WHERE collection_requests.collector_id=$1
`

type GetAllCollectionRequestsForACollectorRow struct {
	ID                  int32          `json:"id"`
	ProducerID          int32          `json:"producer_id"`
	CollectorID         int32          `json:"collector_id"`
	RequestDate         time.Time      `json:"request_date"`
	PickupDate          sql.NullTime   `json:"pickup_date"`
	Confirmed           sql.NullBool   `json:"confirmed"`
	Cancelled           sql.NullBool   `json:"cancelled"`
	Status              sql.NullBool   `json:"status"`
	CreatedAt           time.Time      `json:"created_at"`
	AggregatorName      sql.NullString `json:"aggregator_name"`
	ChampionName        sql.NullString `json:"champion_name"`
	SecondCollectorName sql.NullString `json:"second_collector_name"`
}

func (q *Queries) GetAllCollectionRequestsForACollector(ctx context.Context, collectorID int32) ([]GetAllCollectionRequestsForACollectorRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCollectionRequestsForACollector, collectorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCollectionRequestsForACollectorRow{}
	for rows.Next() {
		var i GetAllCollectionRequestsForACollectorRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupDate,
			&i.Confirmed,
			&i.Cancelled,
			&i.Status,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompletedCollectionRequests = `-- name: GetAllCompletedCollectionRequests :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_date, collection_requests.confirmed, collection_requests.cancelled, collection_requests.status, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
WHERE collection_requests.status=$1
`

type GetAllCompletedCollectionRequestsRow struct {
	ID                  int32          `json:"id"`
	ProducerID          int32          `json:"producer_id"`
	CollectorID         int32          `json:"collector_id"`
	RequestDate         time.Time      `json:"request_date"`
	PickupDate          sql.NullTime   `json:"pickup_date"`
	Confirmed           sql.NullBool   `json:"confirmed"`
	Cancelled           sql.NullBool   `json:"cancelled"`
	Status              sql.NullBool   `json:"status"`
	CreatedAt           time.Time      `json:"created_at"`
	AggregatorName      sql.NullString `json:"aggregator_name"`
	ChampionName        sql.NullString `json:"champion_name"`
	SecondCollectorName sql.NullString `json:"second_collector_name"`
}

func (q *Queries) GetAllCompletedCollectionRequests(ctx context.Context, status sql.NullBool) ([]GetAllCompletedCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCompletedCollectionRequests, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCompletedCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllCompletedCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupDate,
			&i.Confirmed,
			&i.Cancelled,
			&i.Status,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPendingCollectionRequests = `-- name: GetAllPendingCollectionRequests :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_date, collection_requests.confirmed, collection_requests.cancelled, collection_requests.status, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
WHERE collection_requests.confirmed=$1
`

type GetAllPendingCollectionRequestsRow struct {
	ID                  int32          `json:"id"`
	ProducerID          int32          `json:"producer_id"`
	CollectorID         int32          `json:"collector_id"`
	RequestDate         time.Time      `json:"request_date"`
	PickupDate          sql.NullTime   `json:"pickup_date"`
	Confirmed           sql.NullBool   `json:"confirmed"`
	Cancelled           sql.NullBool   `json:"cancelled"`
	Status              sql.NullBool   `json:"status"`
	CreatedAt           time.Time      `json:"created_at"`
	AggregatorName      sql.NullString `json:"aggregator_name"`
	ChampionName        sql.NullString `json:"champion_name"`
	SecondCollectorName sql.NullString `json:"second_collector_name"`
}

func (q *Queries) GetAllPendingCollectionRequests(ctx context.Context, confirmed sql.NullBool) ([]GetAllPendingCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPendingCollectionRequests, confirmed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllPendingCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllPendingCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupDate,
			&i.Confirmed,
			&i.Cancelled,
			&i.Status,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPendingConfirmationCollectionRequests = `-- name: GetAllPendingConfirmationCollectionRequests :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_date, collection_requests.confirmed, collection_requests.cancelled, collection_requests.status, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
WHERE collection_requests.confirmed=$1
`

type GetAllPendingConfirmationCollectionRequestsRow struct {
	ID                  int32          `json:"id"`
	ProducerID          int32          `json:"producer_id"`
	CollectorID         int32          `json:"collector_id"`
	RequestDate         time.Time      `json:"request_date"`
	PickupDate          sql.NullTime   `json:"pickup_date"`
	Confirmed           sql.NullBool   `json:"confirmed"`
	Cancelled           sql.NullBool   `json:"cancelled"`
	Status              sql.NullBool   `json:"status"`
	CreatedAt           time.Time      `json:"created_at"`
	AggregatorName      sql.NullString `json:"aggregator_name"`
	ChampionName        sql.NullString `json:"champion_name"`
	SecondCollectorName sql.NullString `json:"second_collector_name"`
}

func (q *Queries) GetAllPendingConfirmationCollectionRequests(ctx context.Context, confirmed sql.NullBool) ([]GetAllPendingConfirmationCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPendingConfirmationCollectionRequests, confirmed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllPendingConfirmationCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllPendingConfirmationCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.PickupDate,
			&i.Confirmed,
			&i.Cancelled,
			&i.Status,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestCollection = `-- name: GetLatestCollection :one
SELECT
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.pickup_date, collection_requests.confirmed, collection_requests.cancelled, collection_requests.status, collection_requests.created_at,
    collector.name AS collector_name,
    CAST(SUM(totals.weight) AS DECIMAL(10,2)) AS total_weight
FROM
    collection_requests
LEFT JOIN
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN
    waste_items AS totals ON totals.collection_request_id = collection_requests.id
WHERE
    collection_requests.id = $1
GROUP BY
    collection_requests.id, collector.name
`

type GetLatestCollectionRow struct {
	ID            int32          `json:"id"`
	ProducerID    int32          `json:"producer_id"`
	CollectorID   int32          `json:"collector_id"`
	RequestDate   time.Time      `json:"request_date"`
	PickupDate    sql.NullTime   `json:"pickup_date"`
	Confirmed     sql.NullBool   `json:"confirmed"`
	Cancelled     sql.NullBool   `json:"cancelled"`
	Status        sql.NullBool   `json:"status"`
	CreatedAt     time.Time      `json:"created_at"`
	CollectorName sql.NullString `json:"collector_name"`
	TotalWeight   string         `json:"total_weight"`
}

func (q *Queries) GetLatestCollection(ctx context.Context, id int32) (GetLatestCollectionRow, error) {
	row := q.db.QueryRowContext(ctx, getLatestCollection, id)
	var i GetLatestCollectionRow
	err := row.Scan(
		&i.ID,
		&i.ProducerID,
		&i.CollectorID,
		&i.RequestDate,
		&i.PickupDate,
		&i.Confirmed,
		&i.Cancelled,
		&i.Status,
		&i.CreatedAt,
		&i.CollectorName,
		&i.TotalWeight,
	)
	return i, err
}

const getProducerLatestCollectionId = `-- name: GetProducerLatestCollectionId :one
SELECT id, producer_id, collector_id, request_date, pickup_date, confirmed, cancelled, status, created_at
FROM collection_requests
WHERE producer_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetProducerLatestCollectionId(ctx context.Context, producerID int32) (CollectionRequest, error) {
	row := q.db.QueryRowContext(ctx, getProducerLatestCollectionId, producerID)
	var i CollectionRequest
	err := row.Scan(
		&i.ID,
		&i.ProducerID,
		&i.CollectorID,
		&i.RequestDate,
		&i.PickupDate,
		&i.Confirmed,
		&i.Cancelled,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const insertNewCollectionRequest = `-- name: InsertNewCollectionRequest :exec

insert into collection_requests( producer_id,collector_id,request_date ) values ($1, $2, $3) returning id, producer_id, collector_id, request_date, pickup_date, confirmed, cancelled, status, created_at
`

type InsertNewCollectionRequestParams struct {
	ProducerID  int32     `json:"producer_id"`
	CollectorID int32     `json:"collector_id"`
	RequestDate time.Time `json:"request_date"`
}

// collection_requests.sql
func (q *Queries) InsertNewCollectionRequest(ctx context.Context, arg InsertNewCollectionRequestParams) error {
	_, err := q.db.ExecContext(ctx, insertNewCollectionRequest, arg.ProducerID, arg.CollectorID, arg.RequestDate)
	return err
}

const updateCollectionRequest = `-- name: UpdateCollectionRequest :exec
update collection_requests
set
    pickup_date = $1,
    status = $2
where id = $3
`

type UpdateCollectionRequestParams struct {
	PickupDate sql.NullTime `json:"pickup_date"`
	Status     sql.NullBool `json:"status"`
	ID         int32        `json:"id"`
}

func (q *Queries) UpdateCollectionRequest(ctx context.Context, arg UpdateCollectionRequestParams) error {
	_, err := q.db.ExecContext(ctx, updateCollectionRequest, arg.PickupDate, arg.Status, arg.ID)
	return err
}
