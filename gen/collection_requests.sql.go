// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: collection_requests.sql

package gen

import (
	"context"
	"database/sql"
	"time"
)

const cancelCollectionRequest = `-- name: CancelCollectionRequest :exec
update collection_requests set status = 4 where id = $1
`

func (q *Queries) CancelCollectionRequest(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, cancelCollectionRequest, id)
	return err
}

const collectionWeightTotals = `-- name: CollectionWeightTotals :one
select sum(waste_items.weight) as total_weight,waste_types.name from waste_items 
inner join waste_types on waste_types.id=waste_items.waste_type_id 
inner join collection_requests on collection_requests.id=waste_items.collection_request_id
where collection_requests.producer_id=$1 GROUP BY waste_types.name
`

type CollectionWeightTotalsRow struct {
	TotalWeight int64  `json:"total_weight"`
	Name        string `json:"name"`
}

func (q *Queries) CollectionWeightTotals(ctx context.Context, producerID int32) (CollectionWeightTotalsRow, error) {
	row := q.db.QueryRowContext(ctx, collectionWeightTotals, producerID)
	var i CollectionWeightTotalsRow
	err := row.Scan(&i.TotalWeight, &i.Name)
	return i, err
}

const confirmCollectionRequest = `-- name: ConfirmCollectionRequest :exec
update collection_requests set status = 2 where id = $1
`

func (q *Queries) ConfirmCollectionRequest(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, confirmCollectionRequest, id)
	return err
}

const getAggregatorNewRequests = `-- name: GetAggregatorNewRequests :many
SELECT
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    producer.name AS producer_name,
    producer.location AS producer_location
FROM
    collection_requests
LEFT JOIN
    companies AS producer ON producer.id = collection_requests.producer_id
WHERE
    collection_requests.collector_id = $1 AND collection_requests.status = false
GROUP BY
    collection_requests.id, producer.name, producer.location
`

type GetAggregatorNewRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	ProducerName                 sql.NullString  `json:"producer_name"`
	ProducerLocation             sql.NullString  `json:"producer_location"`
}

func (q *Queries) GetAggregatorNewRequests(ctx context.Context, collectorID int32) ([]GetAggregatorNewRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAggregatorNewRequests, collectorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAggregatorNewRequestsRow{}
	for rows.Next() {
		var i GetAggregatorNewRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.ProducerName,
			&i.ProducerLocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCancelledCollectionRequests = `-- name: GetAllCancelledCollectionRequests :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
WHERE collection_requests.cancelled=4
`

type GetAllCancelledCollectionRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	AggregatorName               sql.NullString  `json:"aggregator_name"`
	ChampionName                 sql.NullString  `json:"champion_name"`
	SecondCollectorName          sql.NullString  `json:"second_collector_name"`
}

func (q *Queries) GetAllCancelledCollectionRequests(ctx context.Context) ([]GetAllCancelledCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCancelledCollectionRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCancelledCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllCancelledCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCollectionRequests = `-- name: GetAllCollectionRequests :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
`

type GetAllCollectionRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	AggregatorName               sql.NullString  `json:"aggregator_name"`
	ChampionName                 sql.NullString  `json:"champion_name"`
	SecondCollectorName          sql.NullString  `json:"second_collector_name"`
}

func (q *Queries) GetAllCollectionRequests(ctx context.Context) ([]GetAllCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCollectionRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCollectionRequestsForACollector = `-- name: GetAllCollectionRequestsForACollector :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
WHERE collection_requests.collector_id=$1
`

type GetAllCollectionRequestsForACollectorRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	AggregatorName               sql.NullString  `json:"aggregator_name"`
	ChampionName                 sql.NullString  `json:"champion_name"`
	SecondCollectorName          sql.NullString  `json:"second_collector_name"`
}

func (q *Queries) GetAllCollectionRequestsForACollector(ctx context.Context, collectorID int32) ([]GetAllCollectionRequestsForACollectorRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCollectionRequestsForACollector, collectorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCollectionRequestsForACollectorRow{}
	for rows.Next() {
		var i GetAllCollectionRequestsForACollectorRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompletedCollectionRequests = `-- name: GetAllCompletedCollectionRequests :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
WHERE collection_requests.status=$1
`

type GetAllCompletedCollectionRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	AggregatorName               sql.NullString  `json:"aggregator_name"`
	ChampionName                 sql.NullString  `json:"champion_name"`
	SecondCollectorName          sql.NullString  `json:"second_collector_name"`
}

func (q *Queries) GetAllCompletedCollectionRequests(ctx context.Context, status int32) ([]GetAllCompletedCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCompletedCollectionRequests, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCompletedCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllCompletedCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPendingCollectionRequests = `-- name: GetAllPendingCollectionRequests :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
WHERE collection_requests.confirmed=2
`

type GetAllPendingCollectionRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	AggregatorName               sql.NullString  `json:"aggregator_name"`
	ChampionName                 sql.NullString  `json:"champion_name"`
	SecondCollectorName          sql.NullString  `json:"second_collector_name"`
}

func (q *Queries) GetAllPendingCollectionRequests(ctx context.Context) ([]GetAllPendingCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPendingCollectionRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllPendingCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllPendingCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPendingConfirmationCollectionRequests = `-- name: GetAllPendingConfirmationCollectionRequests :many
SELECT 
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    champion.name AS aggregator_name,
    collector.name AS champion_name,
    secondcollector.name as second_collector_name
FROM 
    collection_requests
LEFT JOIN 
    companies AS champion ON champion.id = collection_requests.champion_id
LEFT JOIN 
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN 
    companies AS secondcollector ON secondcollector.id = collection_requests.second_collector_id
WHERE collection_requests.status=2
`

type GetAllPendingConfirmationCollectionRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	AggregatorName               sql.NullString  `json:"aggregator_name"`
	ChampionName                 sql.NullString  `json:"champion_name"`
	SecondCollectorName          sql.NullString  `json:"second_collector_name"`
}

func (q *Queries) GetAllPendingConfirmationCollectionRequests(ctx context.Context) ([]GetAllPendingConfirmationCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPendingConfirmationCollectionRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllPendingConfirmationCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllPendingConfirmationCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.AggregatorName,
			&i.ChampionName,
			&i.SecondCollectorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProducerCompletedCollectionRequests = `-- name: GetAllProducerCompletedCollectionRequests :many
SELECT
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    collector.name AS collector_name,
    CAST(SUM(totals.weight) AS DECIMAL(10,2)) AS total_weight
FROM
    collection_requests
LEFT JOIN
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN
    waste_items AS totals ON totals.collection_request_id = collection_requests.id
WHERE
    collection_requests.producer_id = $1 AND collection_requests.status = true
GROUP BY
    collection_requests.id, collector.name
`

type GetAllProducerCompletedCollectionRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	CollectorName                sql.NullString  `json:"collector_name"`
	TotalWeight                  string          `json:"total_weight"`
}

func (q *Queries) GetAllProducerCompletedCollectionRequests(ctx context.Context, producerID int32) ([]GetAllProducerCompletedCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllProducerCompletedCollectionRequests, producerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProducerCompletedCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllProducerCompletedCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.CollectorName,
			&i.TotalWeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProducerPendingCollectionRequests = `-- name: GetAllProducerPendingCollectionRequests :many
SELECT
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    collector.name AS collector_name,
    CAST(SUM(totals.weight) AS DECIMAL(10,2)) AS total_weight
FROM
    collection_requests
LEFT JOIN
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN
    waste_items AS totals ON totals.collection_request_id = collection_requests.id
WHERE
    collection_requests.producer_id = $1 AND collection_requests.status = false
GROUP BY
    collection_requests.id, collector.name
`

type GetAllProducerPendingCollectionRequestsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	CollectorName                sql.NullString  `json:"collector_name"`
	TotalWeight                  string          `json:"total_weight"`
}

func (q *Queries) GetAllProducerPendingCollectionRequests(ctx context.Context, producerID int32) ([]GetAllProducerPendingCollectionRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllProducerPendingCollectionRequests, producerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProducerPendingCollectionRequestsRow{}
	for rows.Next() {
		var i GetAllProducerPendingCollectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.CollectorName,
			&i.TotalWeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionStats = `-- name: GetCollectionStats :many
SELECT
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    CAST(SUM(totals.weight) AS DECIMAL(10,2)) AS total_weight
FROM
    collection_requests
LEFT JOIN
    waste_items AS totals ON totals.collection_request_id = collection_requests.id
WHERE
    collection_requests.producer_id = $1
GROUP BY
    collection_requests.id
`

type GetCollectionStatsRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	TotalWeight                  string          `json:"total_weight"`
}

func (q *Queries) GetCollectionStats(ctx context.Context, producerID int32) ([]GetCollectionStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionStats, producerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCollectionStatsRow{}
	for rows.Next() {
		var i GetCollectionStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.CollectorID,
			&i.RequestDate,
			&i.Location,
			&i.AdministrativeLevel1Location,
			&i.Lat,
			&i.Lng,
			&i.PickupDate,
			&i.Status,
			&i.FirstContactPerson,
			&i.SecondContactPerson,
			&i.CreatedAt,
			&i.TotalWeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestCollection = `-- name: GetLatestCollection :one
SELECT
    collection_requests.id, collection_requests.producer_id, collection_requests.collector_id, collection_requests.request_date, collection_requests.location, collection_requests.administrative_level_1_location, collection_requests.lat, collection_requests.lng, collection_requests.pickup_date, collection_requests.status, collection_requests.first_contact_person, collection_requests.second_contact_person, collection_requests.created_at,
    collector.name AS collector_name,
    CAST(SUM(totals.weight) AS DECIMAL(10,2)) AS total_weight
FROM
    collection_requests
LEFT JOIN
    companies AS collector ON collector.id = collection_requests.collector_id
LEFT JOIN
    waste_items AS totals ON totals.collection_request_id = collection_requests.id
WHERE
    collection_requests.id = $1
GROUP BY
    collection_requests.id, collector.name
`

type GetLatestCollectionRow struct {
	ID                           int32           `json:"id"`
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	Location                     sql.NullString  `json:"location"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	PickupDate                   sql.NullTime    `json:"pickup_date"`
	Status                       int32           `json:"status"`
	FirstContactPerson           string          `json:"first_contact_person"`
	SecondContactPerson          sql.NullString  `json:"second_contact_person"`
	CreatedAt                    time.Time       `json:"created_at"`
	CollectorName                sql.NullString  `json:"collector_name"`
	TotalWeight                  string          `json:"total_weight"`
}

func (q *Queries) GetLatestCollection(ctx context.Context, id int32) (GetLatestCollectionRow, error) {
	row := q.db.QueryRowContext(ctx, getLatestCollection, id)
	var i GetLatestCollectionRow
	err := row.Scan(
		&i.ID,
		&i.ProducerID,
		&i.CollectorID,
		&i.RequestDate,
		&i.Location,
		&i.AdministrativeLevel1Location,
		&i.Lat,
		&i.Lng,
		&i.PickupDate,
		&i.Status,
		&i.FirstContactPerson,
		&i.SecondContactPerson,
		&i.CreatedAt,
		&i.CollectorName,
		&i.TotalWeight,
	)
	return i, err
}

const getProducerLatestCollectionId = `-- name: GetProducerLatestCollectionId :one
SELECT id, producer_id, collector_id, request_date, location, administrative_level_1_location, lat, lng, pickup_date, status, first_contact_person, second_contact_person, created_at
FROM collection_requests
WHERE producer_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetProducerLatestCollectionId(ctx context.Context, producerID int32) (CollectionRequest, error) {
	row := q.db.QueryRowContext(ctx, getProducerLatestCollectionId, producerID)
	var i CollectionRequest
	err := row.Scan(
		&i.ID,
		&i.ProducerID,
		&i.CollectorID,
		&i.RequestDate,
		&i.Location,
		&i.AdministrativeLevel1Location,
		&i.Lat,
		&i.Lng,
		&i.PickupDate,
		&i.Status,
		&i.FirstContactPerson,
		&i.SecondContactPerson,
		&i.CreatedAt,
	)
	return i, err
}

const getWasteItemsProducerData = `-- name: GetWasteItemsProducerData :many
SELECT
    CAST(SUM(waste_items.weight) AS DECIMAL(10,2)) AS total_weight,
    waste.name AS waste_name,
    collections.status AS collection_status
FROM
    waste_items
JOIN
    waste_types AS waste ON waste_items.waste_type_id = waste.id
LEFT JOIN
    collection_requests AS collections ON collections.id = waste_items.collection_request_id
WHERE
    collections.producer_id = $1
GROUP BY
    collections.status, waste.name
`

type GetWasteItemsProducerDataRow struct {
	TotalWeight      string        `json:"total_weight"`
	WasteName        string        `json:"waste_name"`
	CollectionStatus sql.NullInt32 `json:"collection_status"`
}

func (q *Queries) GetWasteItemsProducerData(ctx context.Context, producerID int32) ([]GetWasteItemsProducerDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getWasteItemsProducerData, producerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWasteItemsProducerDataRow{}
	for rows.Next() {
		var i GetWasteItemsProducerDataRow
		if err := rows.Scan(&i.TotalWeight, &i.WasteName, &i.CollectionStatus); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertNewCollectionRequest = `-- name: InsertNewCollectionRequest :exec

insert into collection_requests( producer_id,collector_id,request_date,location,lat,lng,administrative_level_1_location,first_contact_person ) values ($1, $2, $3, $4, $5, $6, $7, $8) returning id, producer_id, collector_id, request_date, location, administrative_level_1_location, lat, lng, pickup_date, status, first_contact_person, second_contact_person, created_at
`

type InsertNewCollectionRequestParams struct {
	ProducerID                   int32           `json:"producer_id"`
	CollectorID                  int32           `json:"collector_id"`
	RequestDate                  time.Time       `json:"request_date"`
	Location                     sql.NullString  `json:"location"`
	Lat                          sql.NullFloat64 `json:"lat"`
	Lng                          sql.NullFloat64 `json:"lng"`
	AdministrativeLevel1Location sql.NullString  `json:"administrative_level_1_location"`
	FirstContactPerson           string          `json:"first_contact_person"`
}

// collection_requests.sql
func (q *Queries) InsertNewCollectionRequest(ctx context.Context, arg InsertNewCollectionRequestParams) error {
	_, err := q.db.ExecContext(ctx, insertNewCollectionRequest,
		arg.ProducerID,
		arg.CollectorID,
		arg.RequestDate,
		arg.Location,
		arg.Lat,
		arg.Lng,
		arg.AdministrativeLevel1Location,
		arg.FirstContactPerson,
	)
	return err
}

const updateCollectionRequest = `-- name: UpdateCollectionRequest :exec
update collection_requests
set
    pickup_date = $1,
    status = $2
where id = $3
`

type UpdateCollectionRequestParams struct {
	PickupDate sql.NullTime `json:"pickup_date"`
	Status     int32        `json:"status"`
	ID         int32        `json:"id"`
}

func (q *Queries) UpdateCollectionRequest(ctx context.Context, arg UpdateCollectionRequestParams) error {
	_, err := q.db.ExecContext(ctx, updateCollectionRequest, arg.PickupDate, arg.Status, arg.ID)
	return err
}
